<html><head><title>Tcl8 bindings for Xapian</title></head>
<body>
<h1>Tcl8 bindings for Xapian</h1>

<p>
The Tcl8 bindings for Xapian are packaged in the <code>xapian</code> namespace,
and largely follow the C++ API, with the following differences and
additions. Tcl8 strings and lists, etc., are converted automatically
in the bindings, so generally it should just work as expected.
</p>

<p>
The <code>examples</code> subdirectory contains examples showing how to use the
Tcl8 bindings based on the simple examples from <code>xapian-examples</code>:
<a href="examples/simpleindex.tcl">simpleindex.tcl</a>,
<a href="examples/simplesearch.tcl">simplesearch.tcl</a>.
<!-- <a href="examples/simpleexpand.py">simpleexpand.py</a>. -->
</p>

<h2>Destructors</h2>

<p>
   To destroy an object <code><i>obj</i></code>, you need to use one of
   <code><i>obj</i> -delete</code> or <code>rename <i>obj</i> ""</code>
   (either should work, but see below).
</p>

<p>
   SWIG's Tcl wrapping doesn't handle an object returned by a factory function
   correctly.  This only matters for the Xapian::WritableDatabase class, and we
   avoid wrapping the two problematic factory functions to avoid setting a
   trap for the unwary - these are the WritableDatabase version of
   <code>Xapian::Quartz::open</code> and the WritableDatabase version of
   <code>Xapian::Auto::open</code>.  The latter is deprecated anyway, and
   you can just use a Xapian::WritableDatabase constructor instead.  There's
   no direct replacement for the former, although at present it's actually
   exactly the same as the latter (since Quartz is the only disk based
   backend which supports writing).
</p>

<p>
  Michael Schlenker reports that this form works (i.e. the destructor gets
  called):

<blockquote><pre>
xapian::WritableDatabase xapiandb testdir $::xapian::DB_CREATE_OR_OVERWRITE
rename xapiandb ""
</pre></blockquote>

  However, apparently none of these forms works:

<blockquote><pre>
xapian::WritableDatabase xapiandb testdir $::xapian::DB_CREATE_OR_OVERWRITE
set db xapiandb
$db -delete

set db [xapian::WritableDatabase xapiandb testdir $::xapian::DB_CREATE_OR_OVERWRITE]
$db -delete

set db [xapian::WritableDatabase xapiandb testdir $::xapian::DB_CREATE_OR_OVERWRITE]
rename $db ""
</pre></blockquote>
</p>

<h2>Exceptions</h2>

<p>
Xapian::Error exceptions can be handled in Tcl like so:
</p>

<pre>
if [catch {
    # Code which might throw an exception.
} msg] {
    # Code to handle exceptions.
    # $errorCode is "XAPIAN <error_class>" (e.g. "XAPIAN DocNotFoundError".)
    # $msg is the result of calling get_msg() on the Xapian::Error object.
}
</pre>

<h2>Iterators</h2>

<p>
   All iterators support <code>next</code> and <code>equals</code> methods
   to move through and test iterators (as for all language bindings).
   MSetIterator and ESetIterator also support <code>prev</code>.
</p>

<h2>Iterator dereferencing</h2>

<p>
   C++ iterators are often dereferenced to get information, eg
   <code>(*it)</code>. With Tcl8 these are all mapped to named methods, as
   follows:
</p>

<table title='Iterator deferencing methods'>
<thead><td>Iterator</td><td>Dereferencing method</td></thead>
<tr><td>PositionIterator</td>	<td><code>get_termpos</code></td></tr>
<tr><td>PostingIterator</td>	<td><code>get_docid</code></td></tr>
<tr><td>TermIterator</td>	<td><code>get_term</code></td></tr>
<tr><td>ValueIterator</td>	<td><code>get_value</code></td></tr>
<tr><td>MSetIterator</td>	<td><code>get_docid</code></td></tr>
<tr><td>ESetIterator</td>	<td><code>get_term</code></td></tr>
</table>

<p>
   Other methods, such as <code>MSetIterator::get_document</code>, are
   available under the same names.
</p>
   
<h2>MSet</h2>

<p>
   MSet objects have some additional methods to simplify access (these
   work using the C++ array dereferencing):
</p>

<table title='MSet additional methods'>
<thead><td>Method name</td><td>Explanation</td></thead>
<tr><td><code>mset get_hit index</code></td><td>returns MSetIterator at index</td></tr>
<tr><td><code>mset get_document_percentage index</code></td><td><code>mset convert_to_percent [mset get_hit index]</code></td></tr>
<tr><td><code>mset get_document index</code></td><td><code>[mset get_hit index] get_document</code></td></tr>
<tr><td><code>mset get_docid index</code></td><td><code>[mset get_hit index] get_docid</code></td></tr>
</table>

<h2>Database Factory Functions</h2>

<ul>
<li> <code>Xapian::Auto::open_stub()</code> is wrapped as <code>xapian::open_stub</code>
<li> <code>Xapian::Quartz::open()</code> is wrapped as <code>xapian::quartz_open</code> (but note that the WritableDatabase version isn't wrapped - see
the 'Destructors' section above for an explanation).
<li> <code>Xapian::InMemory::open()</code> is wrapped as <code>xapian::inmemory_open</code>
<li> <code>Xapian::Remote::open()</code> is wrapped as <code>xapian::remote_open</code> (only
the TCP version is currently wrapped, the "program" version isn't).
</ul>

<h2>Query</h2>

<p>
   In C++ there's a Xapian::Query constructor which takes a query operator and
   start/end iterators specifying a number of terms or queries, plus an optional
   parameter.  In Tcl, this is wrapped to accept a Tcl list
   to give the terms/queries, and you can specify
   a mixture of terms and queries if you wish.  For example:
</p>

<pre>
   set terms [list "hello" "world"]
   xapian::Query subq $xapian::Query_OP_AND $terms
   xapian::Query bar_term "bar" 2
   xapian::Query query $xapian::Query_OP_AND [list subq "foo" bar_term]
</pre>

<h2>Enquire</h2>

<p>
   There is an additional method <code>get_matching_terms</code> which takes
   an MSetIterator and returns a list of terms in the current query which
   match the document given by that iterator.  You may find this
   more convenient than using the TermIterator directly.
</p>

<address>
Last updated $Date$
</address>
</body>
</html>
