<html><head><title>Python bindings for Xapian</title></head>
<body>
<h1>Python bindings for Xapian</h1>

<p>
The Python bindings for Xapian are packaged in the <code>xapian</code> module,
and largely follow the C++ API, with the following differences and
additions. Python strings and lists, etc., are converted automatically
in the bindings, so generally it should just work as expected.
</p>

<p>
The <code>examples</code> subdirectory contains examples showing how to use the
Python bindings based on the simple examples from <code>xapian-examples</code>:
<a href="examples/simpleindex.py">simpleindex.py</a>,
<a href="examples/simplesearch.py">simplesearch.py</a>,
<a href="examples/simpleexpand.py">simpleexpand.py</a>.
There's also 
<a href="examples/simplematchdecider.py">simplematchdecider.py</a>
which shows how to define a MatchDecider in Python.
</p>

<p>
The Python bindings come with a test suite, consisting of two test files:
<code>smoketest.py</code> and <code>pythontest.py</code>. These are run by the
"<code>make check</code>" command, or may be run manually.  By default, they
will display the names of any tests which failed, and then display a count of
tests which run and which failed.  The verbosity may be increased by setting
the "<code>VERBOSE</code>" environment variable: a value of 1 will display
detailed information about failures, and a value of 2 will display further
information about the progress of tests.
</p>

<h2>Exceptions</h2>

<p>
   Xapian exceptions are translated into Python exceptions with the same names
   and inheritance hierarchy as the C++ exception classes.  The base class of
   all Xapian exceptions is the <code>xapian.Error</code> class, and this in
   turn is a child of the standard python <code>exceptions.Exception</code>
   class.
</p>
<p>
   This means that programs can trap all xapian exceptions using "<code>except
   xapian.Error</code>", and can trap all exceptions which don't indicate that
   the program should terminate using "<code>except Exception</code>".
</p>

<h2>Unicode</h2>

<p>
   The xapian Python bindings accept unicode strings as well as simple strings
   (ie, "str" type strings) at all places in the API which accept string data.
   Any unicode strings supplied will automatically be translated into UTF-8
   simple strings before being passed to the Xapian core.  The Xapian core is
   largely agnostic about character set, but in those places where it does
   process data in a character set dependent way it assumes that the data is in
   UTF-8.  The Xapian Python bindings always return string data as simple
   strings.
</p>
<p>
   Therefore, in order to avoid issues with character sets, you should always
   pass text data to Xapian as unicode strings, or UTF-8 encoded simple
   strings.  There is, however, no requirement for simple strings passed into
   Xapian to be valid UTF-8 encoded strings, unless they are being passed to a
   text processing routine (such as the query parser, or the stemming
   algorithms).  For example, it is perfectly valid to pass arbitrary binary
   data in a simple string to the <code>xapian.Document.set_data()</code>
   method.
</p>
<p>
   It is often useful to normalise unicode data before passing it to Xapian -
   Xapian currently has no built-in support for normalising unicode
   representations of data.  The standard python module
   "<code>unicodedata</code>" provides support for normalising unicode: you
   probably want the "<code>NFKC</code>" normalisation scheme: in other words,
   use something like
</p>
<pre>
   unicodedata.normalize('NFKC', u'foo')
</pre>
<p>
   to normalise the string "foo" before passing it to Xapian.
</p>

<h2>Iterators</h2>

<p>
   All iterators support <code>next()</code> and <code>equals()</code> methods
   to move through and test iterators (as for all language bindings).
   MSetIterator and ESetIterator also support <code>prev()</code>.
   Python-wrapped iterators also support direct comparison, so something like:
</p>

<pre>
   m=mset.begin()
   while m!=mset.end():
     # do something
     m.next()
</pre>

<h2>Iterator dereferencing</h2>

<p>
   C++ iterators are often dereferenced to get information, eg
   <code>(*it)</code>. With Python these are all mapped to named methods, as
   follows:
</p>

<table title="Iterator deferencing methods">
<thead><td>Iterator</td><td>Dereferencing method</td></thead>
<tr><td>PositionIterator</td>	<td><code>get_termpos()</code></td></tr>
<tr><td>PostingIterator</td>	<td><code>get_docid()</code></td></tr>
<tr><td>TermIterator</td>	<td><code>get_term()</code></td></tr>
<tr><td>ValueIterator</td>	<td><code>get_value()</code></td></tr>
<tr><td>MSetIterator</td>	<td><code>get_docid()</code></td></tr>
<tr><td>ESetIterator</td>	<td><code>get_term()</code></td></tr>
</table>

<p>
   Other methods, such as <code>MSetIterator.get_document()</code>, are
   available unchanged.
</p>

<h2>Pythonic iterators</h2>

<p>
Many classes that support C++-style iterators also support Pythonic
iterators which do the same thing in a Python style. The following are
supported (where marked as default iterator, it means __iter__() does the right
thing so you can for instance use <code>for term in document</code> to
iterate over terms in the Document):
</p>

<table title="Python iterators">
<thead><td>Class</td><td>Method</td><td>Equivalent to</td><td>Iterator type</td></thead>
<tr><td><code>MSet</code></td><td>default iterator</td><td><code>begin()</code></td><td><code>MSetIter</code></td></tr>
<tr><td><code>ESet</code></td><td>default iterator</td><td><code>begin()</code></td><td><code>ESetIter</code></td></tr>
<tr><td><code>Enquire</code></td><td><code>matching_terms()</code></td><td><code>get_matching_terms_begin()</code></td><td><code>TermIter</code></td></tr>
<tr><td><code>Query</code></td><td>default iterator</td><td><code>get_terms_begin()</code></td><td><code>TermIter</code></td></tr>
<tr><td><code>Database</code></td><td><code>allterms()</code></td><td><code>allterms_begin()</code> (also as default iterator)</td><td><code>TermIter</code></td></tr>
<tr><td><code>Database</code></td><td><code>postlist(tname)</code></td><td><code>postlist_begin(tname)</code></td><td><code>PostingIter</code></td></tr>
<tr><td><code>Database</code></td><td><code>termlist(docid)</code></td><td><code>termlist_begin(docid)</code></td><td><code>TermIter</code></td></tr>
<tr><td><code>Database</code></td><td><code>positionlist(docid, tname)</code></td><td><code>positionlist_begin(docid, tname)</code></td><td><code>PositionIter</code></td></tr>
<tr><td><code>Document</code></td><td><code>values()</code></td><td><code>values_begin()</code></td><td><code>ValueIter</code></td></tr>
<tr><td><code>Document</code></td><td><code>termlist()</code></td><td><code>termlist_begin()</code> (also as default iterator)</td><td><code>TermIter</code></td></tr>
<tr><td><code>QueryParser</code></td><td><code>stoplist()</code></td><td><code>stoplist_begin()</code></td><td><code>TermIter</code></td></tr>
<tr><td><code>QueryParser</code></td><td><code>unstemlist(tname)</code></td><td><code>unstem_begin(tname)</code></td><td><code>TermIter</code></td></tr>
</table>

<p>
The Pythonic iterators used to return lists representing the appropriate item when their <code>next()</code> method is called, except PositionIter which just returns a single value.  They now return Python objects, allowing lazy evaluation of properties where appropriate, and allowing a more pythonic access to attribute values.  The sequence API is being maintained for now, so existing code should continue to work, but we recommend transitioning to the new API.  The sequence API is planned to be removed at release 1.1.0 of Xapian.
</p>

<table title="Sequence API equivalents">
<thead><td>Class</td><td>Returns</td></thead>
<tr><td><code>MSetIter</code></td><td>[docid, weight, rank, percentage, document]</td></tr>
<tr><td><code>ESetIter</code></td><td>[term, weight]</td></tr>
<tr><td><code>TermIter</code></td><td>[term, wdf, termfreq, position iterator]</td></tr>
<tr><td><code>PostingIter</code></td><td>[docid, doclength, wdf, position iterator]</td></tr>
<tr><td><code>PositionIter</code></td><td>termpos</td></tr>
<tr><td><code>ValueIter</code></td><td>[valueno, value]</td></tr>
</table>
   
<p>
The lazy evaluation is mainly transparent, but does become visible in one situation: if you keep an object returned by an iterator, without evaluating its properties to force the lazy evaluation to happen, and then move the iterator forward, the object may no longer be able to efficiently perform the lazy evaluation.  In this situation, an exception will be raised indicating that the information requested wasn't available.  This will only happen for a few of the properties - most are either not evaluated lazily (because the underlying Xapian implementation doesn't evaluated them lazily, so there's no advantage in lazy evaluation), or can be accessed even after the iterator has moved.  The simplest work around is simply to evaluate any properties you wish to use which are affected by this before moving the iterator.  The complete set of iterator properties affected by this is:
</p>

<ul>
<li>
Database.allterms (also accessible as Database.__iter__): <b>termfreq</b>
</li><li>
Database.termlist: <b>termfreq</b> and <b>positer</b>
</li><li>
Document.termlist (also accessible as Document.__iter__): <b>termfreq</b> and <b>positer</b>
</li><li>
Database.postlist: <b>positer</b>
</li>
</ul>

<h2>MSet</h2>

<p>
   MSet objects have some additional methods to simplify access (these
   work using the C++ array dereferencing):
</p>

<table title="MSet additional methods">
<thead><td>Method name</td><td>Explanation</td></thead>
<tr><td><code>get_hit(index)</code></td><td>returns MSetIterator at index</td></tr>
<tr><td><code>get_document_percentage(index)</code></td><td><code>convert_to_percent(get_hit(index))</code></td></tr>
<tr><td><code>get_document(index)</code></td><td><code>get_hit(index).get_document()</code></td></tr>
<tr><td><code>get_docid(index)</code></td><td><code>get_hit(index).get_docid()</code></td></tr>
</table>

<p>
Additionally, the MSet has a property, <code>mset.items</code>, which returns a
list of tuples representing the MSet; this may be more convenient than using
the MSetIterator. The members of the tuple are as follows.
</p>

<table title="MSet.items member members">
<thead><td>Index</td><td>Contents</td></thead>
<tr><td><code>xapian.MSET_DID</code></td><td>Document id</td></tr>
<tr><td><code>xapian.MSET_WT</code></td><td>Weight</td></tr>
<tr><td><code>xapian.MSET_RANK</code></td><td>Rank</td></tr>
<tr><td><code>xapian.MSET_PERCENT</code></td><td>Percentage weight</td></tr>
</table>

<p>
Two MSet objects are equal if they have the same number and maximum possible
number of members, and if every document member of the first MSet exists at the
same index in the second MSet, with the same weight.
</p>

<h2>ESet</h2>

<p>
The ESet has a property, <code>eset.items</code>, which returns a list of
tuples representing the ESet; this may be more convenient than using the
ESetIterator. The members of the tuple are as follows.
</p>

<table title="ESet.items member members">
<thead><td>Index</td><td>Contents</td></thead>
<tr><td><code>xapian.ESET_TNAME</code></td><td>Term name</td></tr>
<tr><td><code>xapian.ESET_WT</code></td><td>Weight</td></tr>
</table>

<h2>Database Factory Functions</h2>

<ul>
<li> <code>Xapian::Auto::open_stub()</code> is wrapped as <code>xapian.open_stub()</code>
<li> <code>Xapian::Quartz::open()</code> is wrapped as <code>xapian.quartz_open()</code>
<li> <code>Xapian::InMemory::open()</code> is wrapped as <code>xapian.inmemory_open()</code>
<li> <code>Xapian::Remote::open()</code> is wrapped as <code>xapian.remote_open()</code> (only
the TCP version is currently wrapped, the "program" version isn't).
</ul>

<h2>Query</h2>

<p>
   In C++ there's a Xapian::Query constructor which takes a query operator and
   start/end iterators specifying a number of terms or queries, plus an optional
   parameter.  In Python, this is wrapped to accept any Python sequence (for
   example a list or tuple) to give the terms/queries, and you can specify
   a mixture of terms and queries if you wish.  For example:
</p>

<pre>
   subq = xapian.Query(xapian.Query.OP_AND, "hello", "world")
   q = xapian.Query(xapian.Query.OP_AND, [subq, "foo", xapian.Query("bar", 2)])
</pre>

<h2>Enquire</h2>

<p>
   There is an additional method <code>get_matching_terms()</code> which takes
   an MSetIterator and returns a list of terms in the current query which
   match the document given by that iterator.  You may find this
   more convenient than using the TermIterator directly.
</p>

<h2>MatchDecider</h2>

<p>
Custom MatchDeciders can be created in Python; simply subclass
xapian.MatchDecider, ensure you call the super-constructor, and define a
__call__ method that will do the work. The simplest example (which does nothing
useful) would be as follows:
</p>

<pre>
class mymatchdecider(xapian.MatchDecider):
  def __init__(self):
    xapian.MatchDecider.__init__(self)

  def __call__(self, doc):
    return 1
</pre>

<address>
Last updated $Date$
</address>
</body>
</html>
