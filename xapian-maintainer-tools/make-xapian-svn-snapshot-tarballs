#!/usr/bin/perl -w
use strict;
use Fcntl ':flock';
use File::Path;
use Sys::Hostname;

my $MAXLOADPERCPU = 1.5;

my $last_cmd;

sub run_command {
    if (scalar @_ == 1) {
	$last_cmd = $_[0];
    } else {
	my %a = @_;
	$last_cmd = $a{String};
    }
    my $out = `$last_cmd`;
    chomp $out;
    return wantarray ? split /\n/, $out : $out;
}

my $force = 0;
if (scalar @ARGV && $ARGV[0] eq '--force') {
    shift @ARGV;
    $force = 1;
}

# Configuration:
my $work = "/u1/olly/xapian-svn-snapshot";
$ENV{PATH} = "/u1/olly/install/bin:/usr/bin:/bin";
my $repourl = 'file:///usr/data/xapian-svn/xapian';
my $repourl2 = 'file:///usr/data/xapian-svn/search-xapian';

# Create the work directory first, since we need it to exist so we can create
# the lockfile.
mkpath($work, 0, 0755);
chdir $work or die $!;

# Prevent multiple instances of this script from running at once.
open LOCK, ">flockme" or die "Couldn't open 'flockme' for writing: $!\n";
unless (flock LOCK, LOCK_EX|LOCK_NB) {
    # Work directory already in use.  Don't print anything or the cron job will
    # send it as mail, which we don't really want.
    exit 1;
}

# Check the load average AFTER getting the lock, since we generate output if
# the load is too high, and it will probably be too high if we're already
# running.
my $HOSTNAME = Sys::Hostname::hostname();
# Check the load average isn't too high.
if ((run_command("uptime 2>/dev/null"))[0] =~ /.*: (\d+(?:\.\d+)?),/) {
    if ($1 > $MAXLOADPERCPU) {
	my $loadavg = $1;
	# `getconf _NPROCESSORS_ONLN` on linux gives e.g. 2
	# `sysctl hw.ncpu` on openbsd (and prob. freebsd & darwin) gives e.g. hw.ncpu=2
	# `psrinfo|grep -c on-line` on Solaris or OSF/1 gives e.g. 2
	my $ncpu;
	# Works on Linux, at least back to kernel 2.2.26.
	$ncpu ||= run_command("getconf _NPROCESSORS_ONLN 2>/dev/null|grep -v '[^0-9]'");
	# Works on OpenBSD (and apparently FreeBSD and Darwin).
	$ncpu ||= run_command("sysctl hw.ncpu 2>/dev/null|sed 's/.*=//'");
	# Works on Solaris and OSF/1.
	$ncpu ||= run_command("PATH=/usr/sbin:\$PATH psrinfo 2>/dev/null|grep -c on-line");
	# Works on Linux, just in case the getconf version doesn't.  Different
	# architectures have different formats for /proc/cpuinfo so this won't
	# work as widely as getconf _NPROCESSORS_ONLN will.
	$ncpu ||= run_command("grep -c processor /proc/cpuinfo 2>/dev/null");
	$ncpu ||= 1;
	if ($loadavg > $ncpu * $MAXLOADPERCPU) {
	    $ncpu ||= "unknown";
	    print STDERR "$HOSTNAME: High load average: $loadavg ($ncpu CPUs)\n";
	    exit(1);
	}
    }
}

# If no tags specified, default to those which there are directories for.
# Don't bother to build tags/* since those (generally) don't change.
if (scalar @ARGV == 0) {
    @ARGV = grep /\/[A-Za-z0-9][-A-Za-z0-9_.]*$/ && -d $_,
	glob('branches/[A-Za-z0-9]*');
    -d "trunk" && unshift @ARGV, "trunk";
}

# Or if there are no directories, default to the trunk.
if (scalar @ARGV == 0) {
    @ARGV = 'trunk';
}

my $status = 0;
foreach my $tag (@ARGV) {
    # SVN tag names aren't restricted like CVS ones, but restrict to sane
    # characters.
    next if $tag !~ /^[-A-Za-z0-9_.\/]+$/;
    if (! -d $tag) {
	print "*** No directory for '$tag'\n";
	$status = 1;
	next;
    }

    my $logfile = "$tag/snapshot.log";
    my $log = '';
    my $lastlog;
    my $co_dir = "$tag/xapian";
    if (! -d "$co_dir/.svn") {
        system "rm", "-rf", $co_dir;
	# Check out the tag into a directory of the same name.
	open SVN, "svn co --non-interactive \Q$repourl/$tag\E \Q$co_dir\E 2>&1|" or die $!;
	while (<SVN>) {
	    $log .= $_;
	    $lastlog = $_;
	}
	close SVN or die $!;
    } else {
        # Revert any local changes.
	$log = "svn revert:\n".`svn revert -R \Q$co_dir\E 2>&1`."svn up:\n";
	open SVN, "svn up --non-interactive \Q$co_dir\E 2>&1|" or die $!;
	my $lines = 0;
	while (<SVN>) {
	    $log .= $_;
	    $lastlog = $_;
	    ++$lines;
	    if (/^C. / || /^.C /) {
                # But we just reverted any local changes!
		die "A conflict?!  That should be impossible!\n";    
	    }
	}
	close SVN or die $!;
	if (!$force && $lines <= 1) {
	    # No changes.
	    next;
	}
    }
    my ($revision) = ($lastlog =~ /\b(\d+)\b/);

    open LOG, ">", "$logfile.$revision" or die $!;
    # Flush output after every print.
    my $old_fh = select(LOG);
    $| = 1;
    select($old_fh);

    print LOG $log;
    $log = undef;

    if ($tag !~ m!^tags/!) {
	# Modify configure.ac files to insert $revision into version string.
	foreach my $configure_ac
	    (glob("\Q$co_dir\E/*/configure.ac"),
	     glob("\Q$co_dir\E/*/*/configure.ac")) {
	    open OUT, ">", "tmp.out" or die $!;
	    open IN, "<", $configure_ac or die $!;
	    while (<IN>) {
		s/(^AC_INIT\([^,]*,.*?)(\s*[),])/$1_svn$revision$2/g;
		print OUT;
	    }
	    close IN or die $!;
	    close OUT or die $!;
	    rename "tmp.out", $configure_ac;
	}
    }

    system "rm", "-rf", "$tag/build";
    mkpath("$tag/build", 0, 0755) or die $!;
    chdir "$tag/build" or die $!;

    $log = `../xapian/bootstrap 2>&1`;
    print LOG $log;
    if ($?) {
	print "*** bootstrap failed for '$tag':";
	print $log;
	$status = 1;
	next;
    }
    $log = undef;

    $log = `./configure --enable-maintainer-mode 2>&1`;
    print LOG $log;
    if ($?) {
	print "*** configure failed for '$tag':";
	print $log;
	$status = 1;
	next;
    }
    $log = undef;

    $log = `make 2>&1`;
    print LOG $log;
    if ($?) {
	print "*** make failed for '$tag':";
	print $log;
	$status = 1;
	next;
    }
    $log = undef;

    $log = `make dist 2>&1`;
    print LOG $log;
    if ($?) {
	print "*** make dist failed for '$tag':";
	print $log;
	$status = 1;
	next;
    }
    $log = undef;

    # snapshots of Search::Xapian
    if ($tag eq 'trunk') {
	# We're in $tag/build and Search::Xapian must be bootstrapped in-tree.
	my $co_dir = "search-xapian";
	if (! -d "$co_dir/.svn") {
	    system "rm", "-rf", $co_dir;
	    # Check out the tag into a directory of the same name.
	    open SVN, "svn co --non-interactive \Q$repourl2\E \Q$co_dir\E 2>&1|" or die $!;
	    while (<SVN>) {
		$log .= $_;
		$lastlog = $_;
	    }
	    close SVN or die $!;
	} else {
	    # Revert any local changes.
	    $log = "svn revert:\n".`svn revert -R \Q$co_dir\E 2>&1`."svn up:\n";
	    open SVN, "svn up --non-interactive \Q$co_dir\E 2>&1|" or die $!;
	    my $lines = 0;
	    while (<SVN>) {
		$log .= $_;
		$lastlog = $_;
		++$lines;
		if (/^C. / || /^.C /) {
		    # But we just reverted any local changes!
		    die "A conflict?!  That should be impossible!\n";    
		}
	    }
	    close SVN or die $!;
#	    next if ($lines <= 1);
	}
	my ($revision) = ($lastlog =~ /\b(\d+)\b/);

	open LOG2, ">", "../search-xapian.snapshot.log.$revision" or die $!;
	# Flush output after every print.
	my $old_fh = select(LOG2);
	$| = 1;
	select($old_fh);

	print LOG2 $log;
	$log = undef;

#	if ($tag !~ m!^tags/!) {
#	    # Modify configure.ac files to insert $revision into version string.
#	    foreach my $configure_ac
#		(glob("\Q$tag\E/xapian/*/configure.ac"),
#		 glob("\Q$tag\E/xapian/*/*/configure.ac")) {
#		open OUT, ">", "tmp.out" or die $!;
#		open IN, "<", $configure_ac or die $!;
#		while (<IN>) {
#		    s/(^AC_INIT\([^,]*,.*?)(\s*[),])/$1_svn$revision$2/g;
#		    print OUT;
#		}
#		close IN or die $!;
#		close OUT or die $!;
#		rename "tmp.out", $configure_ac;
#	    }
#	}

	chdir "search-xapian" or die $!;

	my $here = `pwd`;
	chomp($here);
	$log = `XAPIAN_CONFIG=$here/../xapian-core/xapian-config perl Makefile.PL 2>&1`;
	print LOG2 $log;
	if ($?) {
	    print "*** search-xapian bootstrap failed for '$tag':";
	    print $log;
	    $status = 1;
	    next;
	}
	$log = undef;

#	$log = `make disttest 2>&1`;
#	print LOG2 $log;
#	if ($?) {
#	    print "*** make disttest failed for '$tag':";
#	    print $log;
#	    $status = 1;
#	    next;
#	}
#	$log = undef;

	$log = `make dist 2>&1`;
	print LOG2 $log;
	if ($?) {
	    print "*** make dist failed for '$tag':";
	    print $log;
	    $status = 1;
	    next;
	}
	$log = undef;

	chdir "../..";
    }

    my $d = "/usr/data/www/oligarchy.co.uk/xapian/$tag";
    if ($tag =~ m!^tags/([\d.]+)$!) {
	$d = "/usr/data/www/oligarchy.co.uk/xapian/$1";
    }
    if (! -d $d) {
	mkpath($d, 0, 0755) or die $!;
	open HTACCESS, ">", "$d/.htaccess" or die $!;
	print HTACCESS "IndexOptions NameWidth=*\n";
	close HTACCESS or die $!;
    } else {
	if (-d "$d/old") {
	    my @o = glob "$d/old/*.tar.gz";
	    my $n = scalar @o;
	    @o = grep {-M $_ > 7} @o;
	    $n -= scalar @o;
	    # Delete snapshots more than a week old, but leave at least one.
	    unlink @o if $n > 0;
	} else {
	    mkdir "$d/old", 0755 or die $!;
	    open HTACCESS, ">", "$d/old/.htaccess" or die $!;
	    print HTACCESS "IndexOptions NameWidth=*\n";
	    close HTACCESS or die $!;
	}
	for (glob "$d/*.tar.gz") {
	    my ($leaf) = m!([^/]*)$!;
	    rename $_, "$d/old/$leaf";
	}
    }
    chdir("build");
    for (glob("*/*.tar.gz"), glob("xapian-applications/*/*.tar.gz")) {
	print LOG "Moving '$_' to '$d'\n";
	system("mv", $_, $d);
	if ($?) {
	    print LOG "Failed with exit code $?\n";
	} else {
	    print LOG "OK\n";
	}
    }
    for (glob("search-xapian/*.tar.gz")) {
	print LOG2 "Moving '$_' to '$d'\n";
	system("mv", $_, $d);
	if ($?) {
	    print LOG2 "Failed with exit code $?\n";
	} else {
	    print LOG2 "OK\n";
	}
    }
    chdir("../..");
}

# Expire logs more than 10 days old
unlink grep {-M $_ > 10} glob 'snapshot.log.*';

exit($status);
