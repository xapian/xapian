<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Muscat: Quickstart</TITLE>
</HEAD>
<BODY BGCOLOR="white">

<H1>Quickstart</H1>

<P>
This document contains sufficient information to enable you to build your
first application using Muscat.  It does not attempt to provide complete
coverage of all the features of Muscat: for that, see the accompanying
user manual and reference document.
</P><P>
The document contains a quick introduction to the basic concepts, and then
a walk-through development of a simple application using the Muscat
library, together with commentary on how the application could be taken
further.
</P>

<HR>
<H2>Requirements</H2>

<P>
Before following the steps outlined in this document, you will need to have
the Muscat library installed on your system.
For instructions on obtaining and installing Muscat, read the
<A HREF="intro.html">Introduction</A> document.
</P>
<P>
You will also need a reasonably recent C++ compiler.  We currently use GCC
version 2.95.2, but any reasonably ANSI compilant C++ compiler should have
a decent chance of successfully compiling the code.
</P>
<P>
In addition, to run the examples, you will need a version of Muscat compiled
with support for the "sleepycat" database access method.  This requires a copy
of the Berkeley Database library, from Sleepycat software, to be installed on
your system, and for Muscat to be compiled to use this (by passing the
--enable-backend-sleepy parameter to the configuration script).  The sleepycat
database system is available for most architectures, free for open source
projects, from
<A HREF="http://www.sleepycat.com/">http://www.sleepycat.com/</A>
</P>
<P>
If you don't have this library available, there is at the time of writing
no database access method which allows you to write databases to permanent
storage.  As a temporary measure, you could use the InMemory database
method, which keeps a database entirely in memory, and either search the
database directly, or write it to a text file and create a DA file from it,
using the makeDA utility (which is binary only, and available only for Linux).
</P>
<P>
Other access methods will be written in due course, and in the meantime
this guide should be useful to you as an overview of how the system works.
</P>

<HR>
<H2>Databases</H2>

<P>
An information retrieval system using Muscat typically has two parts.  The
first part is the <EM>indexer</EM>, which takes documents in various
formats, processes them so that they can be efficiently searched, and
stores the processed documents in an appropriate data structure (the
<EM>database</EM>).  The second part is the <EM>searcher</EM>, which takes
queries and reads the database to return a list of the documents relevant
to each query.
</P>
<P>
The database is the data structure which ties the indexer and searcher
together, and is fundamental to the retrieval process.  Given how
fundamental it is, it is unsurprising that different applications put
different demands on the database.  For example, some applications may be
happy to deal with searching a static collection of data, but need to do
this extremely fast (for example, a web search engine which builds new
databases from scratch nightly or even weekly).  Other applications may
require that new data can be added to the system incrementally, but don't
require extremely high performance searching (perhaps an email system,
which is only being searched occasionally).  There are many other
constraints which may be placed on an information retrieval system: for
example, it may be required to have small database sizes, even at the
expense of getting poorer results from the system.
</P>
<P>
To provide the required flexibility, Muscat has the ability to use one of
many available database <EM>backends</EM>, each of which satisfies a
different set of constraints, stores its data in a different way.

Currently, these must be compiled into the whole system, and selected at
runtime, but the ability to dynamically load modules for each of these
backends is likely to be added in future, and would require little design
modification.
</P>
<P>
If you are in a real hurry, you could probably skip the rest of this
section, but it is helpful to understand roughly what information Muscat
stores in a database and how it is structured, and the following
subsections detail this.
</P>

<H3>The contents of a database</H3>

<P>
FIXME: to be written.
Documents, terms, data, keys.
What can be accessed fast, what can't.
How each piece of data might be stored.
</P>

<H3><A NAME="sleepycat_databases">SleepyCat databases</A></H3>

<P>
FIXME: to be written.
</P>

<H3><A NAME="da_databases">DA databases</A></H3>

<P>
The DA database format is one of the formats which our original software
uses to store data.  It is a non-modifiable format; all the data must be
known at the time at which it is created.  As a result, it is a fairly
efficient database format for searching.
</P>
<P>
On the other hand, it does lack a couple of features available in the
sleepycat database, one of which is that is does not store positional
information in the posting lists.  Because of this, some operations
(such as phrase searching) will never be possible with this database format.
</P>
<P>
Another disadvantage is that document length information is not stored in
this database, so the full benefit of some weighting formulae will not be
realised.  Despite this, pretty good results can be obtained with DA
databases.
</P>
<P>
Because the DA format is an old format, we do not provide software to
create DA files directly.  However, you may use the makeDA utility to
create these files, either from text data which you have hand prepared,
or from data unloaded from a sleepycat (or other format) database.
</P>
<P>
You can search a DA database in exactly the same way as you would search a
sleepycat database (see the <A HREF="#searcher">example searcher</A>).
</P>

<HR>
<H2><A NAME="indexer">An example indexer</A></H2>

<P>
The code for this example is in the examples package, in
the &quot;<CODE>simple</CODE>&quot; subdirectory.  An HTML formatted
version is available <A HREF="simpleindex.cc.html">here</A>.
</P>
<P>
The &quot;indexer&quot; presented here is simply a small program which
takes a path to a database and a set of parameters defining a document on
the command line, and stores that document as a new entry in the database.
</P>
<H3>Include header files</H3>
<P>
The first requirement in any program using the Muscat library is to
include the Muscat header file, &quot;<CODE>om.h</CODE>&quot;.
This should be installed in a subdirectory &quot;<CODE>om</CODE>&quot; of
a directory on the include path, so:
<PRE>    #include &lt;om/om.h&gt;</PRE>
</P>
<P>
Our example only has a single function, main(), so next we start that:
<PRE>    int main(int argc, char *argv[])</PRE>
</P>
<H3>Options parsing</H3>
<P>
For this example we do very simple options parsing.  We are going to
use the core functionality of Muscat of searching for specific terms in the
database, and we are not going to use any of the extra facilities, such as
the keys which may be associated with each document.  We are also going to
store a simple string as the data associated with each document.
</P><P>
Thus, our command line syntax is:
<UL><LI>
<B>Parameter 1</B> - the (possibly relative) path to the database.
</LI><LI>
<B>Parameter 2</B> - the string to be stored as the document data.
</LI><LI>
<B>Parameters 3 onward</B> - the terms to be stored in the database.  The
terms will be assumed to occur at successive positions in the document.
</LI></UL>
</P><P>
The validity of a command line can therefore be checked very simply by
ensuring that there are at least 3 parameters:
<PRE>
    if(argc &lt; 4) {
        cout &lt;&lt; "usage: " &lt;&lt; argv[0] &lt;&lt;
	        " &lt;path to database> &lt;document data> &lt;document terms>" &lt;&lt; endl;
        exit(1);
    }
</PRE>
</P>

<H3>Catching exceptions</H3>
<P>
When an error occurs in Muscat it is reported by means of the C++ exception
mechanism.  All errors in Muscat are derived classes of
<CODE>OmError</CODE>, so simple error handling can be performed by
enclosing all the code in a try-catch block to catch any
<CODE>OmError</CODE> exceptions.  A (hopefully) helpful message can be
extracted from the <CODE>OmError</CODE> object by calling its
<CODE>get_msg()</CODE> method, which returns a human readable string.
</P>
<P>
Note that all calls to the Muscat library should be performed inside a
try-catch block, since otherwise errors will result in uncaught exceptions;
this usually results in the execution aborting.
</P>
<P>
Note also that OmError is a virtual base class, and thus can't be copied:
you must therefore catch exceptions by reference, as in the following example
code:
</P>
<PRE>
    try {
        <B>[code which accesses Muscat]</B>
    }
    catch(OmError &amp; error) {
        cout &lt;&lt; "Exception: " &lt;&lt; error.get_msg() &lt;&lt; endl;
    }
</PRE>

<H3>Opening the database</H3>

<P>
In Muscat, a database is opened for writing by creating an OmWritableDatabase
object.  The constructor for this object takes two arguments.
<OL><LI>
<B>type</B> - this is a string determining the type of the database to open.
The possible values for this depend on which backends are compiled into the
system: if the type is not known an <CODE>OmInvalidArgument</CODE> error will
be thrown.  For this example, we use the &quot;<CODE>sleepycat</CODE>&quot;
database type.
</LI><LI>
<B>parameters</B> - this is a set of parameters to be used to open the
database, stored in an STL vector. The meaning of the parameters is
dependent on the database type: for a sleepycat database there is expected
to be one and only one argument, which is the path (possibly relative to
the current directory) of a directory in which the database files reside.
</LI></OL>
</P>
<P>
If an attempt is made to open a database which doesn't exist, an attempt
to create an empty database in the specified position will be made.
</P>
<P>
If an error occurs when trying to open a database, or to create a new database,
an exception, usually of type <CODE>OmOpeningError</CODE>, will be thrown.
</P>
<P>
The code to open a database for writing is, then:
</P>

<PRE>
    vector&lt;string&gt; parameters;
    parameters.push_back(argv[1]);
    OmWritableDatabase database("sleepycat", parameters);
</PRE>

<H3>Preparing the new document</H3>

<P>
Now that we have the database open, we need to prepare a document to put
in it.  This is done by creating an OmDocumentContents struct, filling
this with data, and then giving it to the database.
</P>

<P>
The first step, then, is to create the document:
</P>
<PRE>
    OmDocumentContents newdocument;
</PRE>

<P>
Next, we associate some data with the document.  The meaning of this data
is entirely user-defined, and is typically structured in some manner to
contain information such as a URL pointing to the source of the data, and
some text which is to be displayed when returning the document as a result
of a search.
</P>
<P>
For our example, we shall simply store the second parameter given on the
command line in the data field:
</P>
<PRE>
    newdocument.data = string(argv[2]);
</PRE>

<P>
The next step is to put the terms which are to be used when searching for
the document into the OmDocumentContents struct.
The members of the OmDocumentContents struct are all public, so can be
accessed directly, but there are also some convenience methods to help
with the process of filling the struct.
</P>
<P>
We shall use the <CODE>add_posting()</CODE> method, which adds an
occurrence of a term to the struct.  The first parameter is the
&quot;<EM>termname</EM>&quot;, which is a string defining the term.  This
string can be anything, as long as the same string is always used to refer
to the same term.  The string will often be the (possibly stemmed) text
of the term, but might be in a compressed, or even hashed, form.
In general, there is no upper limit to the length of a termname, but some
database methods may impose their own limits.
</P>
<P>
The second parameter is the position at which the term occurs within the
document.  These positions start at 1.  This information is used for
some search features such as phrase matching or passage retrieval, but
is not essential to the search.
</P>

<P>
We add postings for terms with the termname given as each of the remaining 
command line parameters:
</P>
<PRE>
    for(int i = 3; i &lt; argc; i++) {
        newdocument.add_posting(argv[i], i - 2);
    }
</PRE>

<H3>Adding the document to the database</H3>

<P>
Finally, we can add the document to the database.  This simply involves
calling <CODE>OmWritableDatabase::add_document()</CODE>, and passing it
the <CODE>OmDocumentContents</CODE> object:
</P>
<PRE>
    database.add_document(newdocument);
</PRE>

<P>
The operation of adding a document is atomic: either the document will be
added, or an exception will be thrown and the document will not be in the
new database.
</P>
<P>
<CODE>add_document()</CODE> returns a value of type <CODE>om_docid</CODE>.
This is the document ID of the newly added document, which is simply a
handle which can be used to access the document in future.
</P>

<HR>
<H2><A NAME="searcher">An example searcher</A></H2>

<P>
The code for this example is also in the examples package, in
the &quot;<CODE>simple</CODE>&quot; subdirectory.  An HTML formatted
version is available <A HREF="simplesearch.cc.html">here</A>.
</P>
<P>
The &quot;searcher&quot; presented here is, like the &quot;indexer&quot;,
simply a small command line driven program.  It takes a path to a database
and some search terms, performs a probabalistic search for documents
represented by those terms and displays a ranked list of matching documents.
</P>

<H3>Setting up</H3>

<P>
Just like &quot;simpleindex&quot;, we have a single-function example.
So we include the Muscat header file, and begin: 
</P>
<PRE>
    #include &lt;om/om.h&gt;

    int main(int argc, char *argv[])
    {
</PRE>

<H3>Options parsing</H3>
<P>
Again, we are going to use no special options, and have a very simple
command line syntax:
<UL><LI>
<B>Parameter 1</B> - the (possibly relative) path to the database.
</LI><LI>
<B>Parameters 2 onward</B> - the terms to be searched for in the database.
</LI></UL>
</P><P>
The validity of a command line can therefore be checked very simply by
ensuring that there are at least 2 parameters:
</P>
<PRE>
    if(argc &lt; 3) {
        cout &lt;&lt; "usage: " &lt;&lt; argv[0] &lt;&lt;
                " &lt;path to database&gt; &lt;search terms&gt;" &lt;&lt; endl;
        exit(1);
    }
</PRE>
</P>

<H3>Catching exceptions</H3>
<P>
Again, this is performed just as it was for the simple indexer.
</P>
<PRE>
    try {
        <B>[code which accesses Muscat]</B>
    }
    catch(OmError &amp; error) {
        cout &lt;&lt; "Exception: " &lt;&lt; error.get_msg() &lt;&lt; endl;
    }
</PRE>

<H3>Specifying the databases</H3>
<P>
Muscat has the ability to search over many databases simultaneously,
possibly even with the databases distributed across a network of machines.
Each database can be in its own format, so, for example, we might have a
system searching across two DA databases and a sleepycat database.
</P>
<P>
This means that, when we are preparing to search, we create an
OmDatabaseGroup object, and give it a set of parameters to specify
databases by successively calling the
<CODE>OmDatabaseGroup::add_database()</CODE> method.
The parameters given to this method are the same as those which would be
used in the constructor of an <CODE>OmWritableDatabase</CODE> to write
to the database.
</P>
<P>
Note that we still use an <CODE>OmDatabaseGroup</CODE> even when we are
going to use only a single database - there is no special case for a single
database.  This keeps everything nice and consistent.
</P>
<PRE>
    OmDatabaseGroup databases;
    vector&lt;string&gt; parameters;
    parameters.push_back(argv[1]);
    databases.add_database("sleepycat", parameters);
</PRE>

<H3>Starting an enquire session</H3>
<P>
All searches across databases by Muscat are performed within the context of
an &quot;<EM>Enquire</EM>&quot; session.  This session is represented by an
<CODE>OmEnquire</CODE> object, and is across a specified collection of
databases.  To change the database collection, it is neccessary to open a
new enquire session, by creating a new <CODE>OmEnquire</CODE> object.
<PRE>
    OmEnquire enquire(databases);
</PRE>
</P>
<P>
An enquire session is also the context within which all other database
reading operations, such as query expansion and reading the data associated
with a document, are performed.
</P>

<H3>Preparing to search</H3>

<P>
We are going to use all command line parameters from the second onward
as terms to search for in the database.  For convenience, we shall store
them in an STL vector.  This is probably the point at which we would want
to apply a stemming algorithm, or any other desired normalisation and
conversion operation, to the terms.
<PRE>
    vector&lt;om_termname&gt; queryterms;
    for (int optpos = 2; optpos &lt; argc; optpos++) {
        queryterms.push_back(argv[optpos]);
    }
</PRE>
</P>

<P>
Queries are represented within muscat by <CODE>OmQuery</CODE> objects, so
the next step is to construct one from our query terms.
By an amazing coincidence, there is a constructor ready to take our vector
of terms and create an <CODE>OmQuery</CODE> object from it.
<PRE>
    OmQuery query(OM_MOP_OR, queryterms.begin(), queryterms.end());
</PRE>
</P>

<P>
You will notice that we had to specify an operation to be performed on
the terms (the <CODE>OM_MOP_OR</CODE> parameter).  If you're interested,
MOP stands for &quot;Match OPeration&quot;.  Queries in Muscat are actually
fairly complex things: a full range of boolean operations can be applied to
queries to restrict the result set, and probabalistic weightings are then
applied to order the results by relevance.  By specifying the OR operation,
we are not performing any boolean restriction, and are performing a
traditional pure probabalistic search.
</P>

<P>
We now print a message out to confirm to the user what the query being
performed is.  This is done with the <CODE>OmQuery::get_description()</CODE>
method, which is mainly included for debugging purposes, and displays
a string representation of the query.
</P>
<PRE>
    cout &lt;&lt; "Performing query `" &lt;&lt;
         query.get_description() &lt;&lt; "'" &lt;&lt; endl;
</PRE>

<H3>Performing the search</H3>
<P>
Now, we are ready to perform the search.  The first step of this is to
give the query object to the enquire session.  Note that the query is
copied at this operation, and that changing the OmQuery object after
setting the query with it has no effect.
</P>
<PRE>
    enquire.set_query(query);
</PRE>

<P>
Next, we ask for the results of the search.  There is no need to tell
Muscat to perform the search: it will do this automatically.  We use
the <CODE>get_mset()</CODE> method to get the results, which are returned
in an <CODE>OmMSet</CODE> object.  (MSet for Match Set)
</P>
<P>
<CODE>get_mset()</CODE> can take many parameters, such as a set of
relevant documents to use, and various options to modify the search,
but we give it the minimum; which is the first document to return (starting
at 0 for the top ranked document), and the maximum number of documents
to return (we specify 10 here):
<PRE>
    OmMSet matches = enquire.get_mset(0, 10);
</PRE>
</P>

<H3>Displaying the results of the search</H3>
<P>
Finally, we display the results of the search.  The results are stored in
a container called <CODE>items</CODE> in the <CODE>OmMSet</CODE> object,
so first we display how many items are in that:
<PRE>
    cout &lt;&lt; matches.items.size() &lt;&lt; " results found" &lt;&lt; endl;
</PRE>
</P>

<P>
Finally, we display each of the items in the container:
<PRE>
    vector&lt;OmMSetItem&gt;::const_iterator i;
    for (i = matches.items.begin();
         i != matches.items.end();
         i++) {
        OmDocument doc = enquire.get_doc(*i);
        cout &lt;&lt; "Document ID " &lt;&lt; i-&gt;did &lt;&lt; "\t";
	cout &lt;&lt; matches.convert_to_percent(*i) &lt;&lt; "% ";
	cout &lt;&lt; "[" &lt;&lt; doc.get_data().value &lt;&lt; "]" &lt;&lt; endl;
    }
</PRE>
</P>

<HR>
<H2>Compiling</H2>

Now that we have the code written, all we need to do is compile it!

<H3>Finding the Muscat library</H3>

<P>
A small utility, &quot;libomus-config&quot;, is installed along with Muscat
to assist you in finding the installed Muscat library, and in generating
the flags to pass to the compiler and linker to compile.  
</P><P>
After a successful compilation, this utility should be in your path, so
you can simply run
<BLOCKQUOTE><CODE>libomus-config --cflags</CODE></BLOCKQUOTE>
to determine the flags to pass to the compiler, and
<BLOCKQUOTE><CODE>libomus-config --libs</CODE></BLOCKQUOTE>
to determine the flags to pass to the linker.

These flags are returned on the utility's standard output (so you could use
backtick notation to include them on your command line).
</P><P>
If your project uses the GNU autoconf tool, you may also use the
<CODE>OM_PATH_LIBOMUS</CODE> macro, which is included as part of Muscat,
and will check for an installation of Muscat and set (and
<CODE>AC_SUBST</CODE>) the <CODE>LIBOMUS_CFLAGS</CODE> and
<CODE>LIBOMUS_LIBS</CODE> variables to
be the flags to pass to the compiler and linker, respectively.
This macro will also allow you to use an uninstalled version of Muscat.
</P><P>
If you don't use GNU autoconf, don't worry about this.
</P>

<H3>Compiling the simple examples</H3>
Once you know the compilation flags, compilation is a simple matter of
invoking the compiler!  For our example, we could compile the two
utilities (simpleindex and simplesearch) with the commands:
<PRE>
c++ simpleindex.cc `libomus-config --libs --cflags` -o simpleindex
c++ simplesearch.cc `libomus-config --libs --cflags` -o simplesearch
</PRE>

<HR>
<H2>Running the examples</H2>

<P>
Once we have compiled the examples, we can build up a simple database as
follows.  Note that we must first create a directory for the database files to
live in; although Muscat will create new empty database files if they do not
yet exist, it will not create a new directory for them.
<PRE>
$ mkdir proverbs
$ ./simpleindex proverbs \
&gt; "people who live in glass houses should not throw stones" \
&gt; people live glass house stone
$ ./simpleindex proverbs \
&gt; "Don't look a gift horse in the mouth" \
&gt; look gift horse mouth
</PRE>
</P>

<P>
Now, we should have a database with a couple of documents in it.  Looking
in the database directory, you should see something like:
<PRE>
$ ls proverbs/
document.db  postlist.db  termid.db  termlist.db  termname.db
</PRE>
</P>
<P>
Given the small amount of data in the database, you may be concerned that
the total size of these files is somewhat over 50k.  Be reassured that the
database is block structured, here consisting of largely empty
blocks, and will behave much better for large databases.  It is worth
noting, however, that the sleepycat backend is not currently very efficient
(in either space or time), and that this will be improving greatly in the
future.
</P>

<P>
We can at last perform searches over the database using the simplesearch
program.
<PRE>
$ ./simplesearch proverbs look
Performing query `look'
1 results found
Document ID 2   50% [Don't look a gift horse in the mouth]
</PRE>
</P>

<HR>
<H2>Further documentation</H2>

For more detailed documentation on the API, there are two pieces of
documentation available.
<UL><LI>
The <A HREF="userman.html">user manual</A>, which is designed as an
introduction to the API.
</LI>
<LI>
An <A HREF="apidoc/html/index.html">API reference</A>, which is automatically extracted from the extensive
comments in the source code by
<EM><A HREF="http://www.stack.nl/~dimitri/doxygen/index.html">Doxygen</A></EM>.
This is distributed together with the source code packages, but in the
event that you do not have a this there is a 
<A HREF="http://open.muscat.com/developer/docs/apidoc/html/index.html">copy</A> 
available on our website.
</LI></UL>

For those interested in how Muscat works internally, there is also
automatically extracted documentation of the full source code, available
on our 
<A HREF="http://open.muscat.com/developer/docs/sourcedoc/html/index.html">website</A>.  You may also build this documentation yourself, if you have Doxygen
installed, by running
<PRE>
    make doxygen_docs
</PRE>
from within the <CODE>docs</CODE> subdirectory of the <CODE>om</CODE> source
tree.

<!-- FOOTER $Author$ $Date$ $Id$ -->
</BODY>
</HTML>
